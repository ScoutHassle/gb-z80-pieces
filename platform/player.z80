SECTION "PLAYER", rom0

playerStartX EQU 80
playerStartY EQU 48

playerMinX EQU 8
playerMaxX EQU 160

playerMinY EQU 16
playerMaxY EQU 128

playerMoveSpeed EQU 1
playerJumpSpeed EQU 6
playerFallSpeed EQU -1
gravity EQU 1
playerMaxFallSpeed EQU -4

initPlayer::
    ; Reset player vars.
    ld hl, playerX
    ld [hl], playerStartX
    ld hl, playerY
    ld [hl], playerStartY

    ld hl, playerGrounded
    ld [hl], $01
    ld hl, playerJumping
    ld [hl], $00
    ld hl, playerVelocityY
    ld [hl], $00
        
    ; Set 0 frame
    ld hl, currFrame
    ld a, $00
    ld [hl], a

.loadPlayerSprite::
    ; Load sprite into memory.
    ld hl, Blob
	ld de, $8000
	ld bc, 48
	call memcpy

    ; Sprite Memory Layout. 4 bytes per sprite.
    ; 0 - Y / 1 - X / 2 - TileNumber / 3 - Attributes

    ; Set sprite attribute data.
    ld hl, $FE00
    ld [hl], playerStartY ; Y

    inc l
    ld [hl], playerStartX ; X

    inc l
    ld [hl], $00 ; TileNumber
    inc l
    ld a, %0001000
    ld [hl], a ; Attributes
ret

updatePlayer::
; Does the following in the following order...
; Input
; Position
; Animation

; OPTIMISATION TO MAKE UP/LEFT AND DOWN/RIGHT SHARE CODE.
.updateInput::
    ld hl, $FF00 ; Input bits
    ld a, %11101111 ; Check for arrows. NOTE: $10 would check buttons.
    ld [hl], a ; So now we have the input...
    ld a, [hl]

.playerRightInput:
    bit $0, [hl] ; check right input
    jr nz, .playerLeftInput
    ; Move right
	ld hl, playerX
	ld a, [hl]
	adc a, playerMoveSpeed
    ld b, a
    sub playerMaxX ; if a>=160
    jp c, .setX ; goto else
    ld b, playerMaxX
    jp .setX

.playerLeftInput:
    bit $01, [hl]
    jr nz, .handleButtonInputs
    ; Move left
	ld hl, playerX
	ld a, [hl]
	sbc a, playerMoveSpeed
    ld b, a
    sub playerMinX ; if a < 8
    jp nc, .setX
    ld b, playerMinX

.setX:
    ; Set playerX - currently in hl
    ld [hl], b ; set new b

; reset
.handleButtonInputs:
    ld hl, $FF00 ; Input bits
    ld a, %11011111 ; Check for arrows. NOTE: $10 would check buttons.
    ld [hl], a ; So now we have the input...
    bit $05, [hl]
    jr nz, .endInput

.handleJumpButton:   
    bit $00, [hl]  ; A
    jr nz, .endInput
    ld hl, playerGrounded
    ld a, [hl]
    cp 1
    jr nz, .endInput

    ld [hl], $00
    ld hl, playerJumping
    ld [hl], $01
    ld hl, playerVelocityY
    ld [hl], playerJumpSpeed
    ld hl, playerJumpTimer
    ld [hl], playerJumpSpeed

.endInput:
    ; Reset.
    ld hl, $FF00
    ld [hl], $FF

.updatePlayerPosition:
    ; X is easy
    ld hl, playerX
    ld a, [hl]
    ld hl, $FE01
    ld [hl], a ; X

.updatePlayerY:
    call findPlayerTile
    ; store current tile value
    ld e, [hl]
    ; so now I want hl + $20
    ld b, $00
    ld c, $20
    add hl, bc ; Tile below us

    ; If below us IS NOT 4, stop
    ld a, [hl]
    sub 4
    jp nz, .isGrounded ; != 4
.noTileBelow:
    ; below == 4, so we fall
    ; Apply gravity
    ld hl, playerVelocityY
    ld a, [hl]
    cp 0
    jr nz, .fall ; Start fall
        ld a, playerFallSpeed
        ld [hl], a
        ld hl, playerGrounded
        ld [hl], $00
        ld hl, playerJumping
        ld [hl], $00
        jp .applyVelocity

   

.fall:
    cp playerMaxFallSpeed
    jr z, .applyVelocity ; no lower

    sub a, gravity
    ld [hl], a
    jp .applyVelocity

.isGrounded:
    ; The tile below us is a floor tile.
    
    ; If we are jumping currently.
    ld hl, playerJumping
    bit $00, [hl]  ; Jumping?
    jr nz, .checkJump


    ; No? Grounded, carry on like that.

.setGrounded:
; kill all this
    ld hl, playerVelocityY
    ld [hl], $00
    ld hl, playerGrounded
    ld [hl], $01
    ld hl, playerJumping
    ld [hl], $00

.checkJump:
.applyVelocity: ; Always called
    ld hl, playerVelocityY
    ld b, [hl]
    ld hl, playerY
    ld a, [hl]
    sbc a, b
    ld [hl], a ; set playerY
 
.setYPosition:
    ld hl, $FE00
    ld [hl], a ; set spriteY

    ; Continue update loop
    jp .updatePlayerAnimation

.continueY:
    ld hl, playerVelocityY
    ld b, [hl]

    ; Now work out if we move are we in the limits?
    ld hl, playerY
    ld a, [hl]   
    sbc a, b
    ld b, a ; shove that in b for a minute.
    sub playerMaxY ; if a>=160
    jp c, .setY ; still falling

    ; Alright hit our limit, kill velocity, ground the player
    ld hl, playerVelocityY
    ld [hl], 0
    ld hl, playerGrounded
    ld [hl], 1

    ; Move playerY back
    ld hl, playerY
    ld b, playerMaxY ; set limit

.setY:
    ld [hl], b ; set playerY

.updateSpriteY:
    ; Update sprite.
    ld hl, playerY
    ld a, [hl]
    ld hl, $FE00
    ld [hl], a ; Y

.updatePlayerAnimation::
    ld hl, currFrame
    inc [hl] ; next frame
	ld a, [hl]
    cp 33
    jr nz, .continue
    ld a, $00
    ld [hl], a ; reset to first frame
.continue:
    ld hl, frames
    ld l, a ; Select frame e.g. frame[a]
    ld a, [hl] ; load tile number into a
    ld hl, $FE02
    ld [hl], a
ret


; hl - Returns the players tile location.
findPlayerTile:
    ld de, playerY
    ld a, [de]       ; Divide by 8
    srl a ; 2
    srl a ; 4
    srl a ; 8

    sub a, 2 ; sub 2 because the sprite starts at 16.
    ld l, a
    ld h, $00
    ; We need 16 bit maths so use hl
    add hl, hl ; 2
    add hl, hl ; 4
    add hl, hl ; 8
    add hl, hl ; 16
    add hl, hl ; 32

    ; Now move across the selected row.
    ld de, playerX
    ld a, [de] ; Max X is 160 so will git into 8bit.
    srl a ; 2
    srl a ; 4
    srl a ; 8
    sub a, 1 ; sub 1 because the sprite start at 8.
    ; Store result
    ld c, a
    ld b, $00
    ; Add it to the Y result in hl.
    add hl, bc
    ; Now move to 9800 + hl
    ld bc, $9800
    add hl, bc
ret

SECTION "player_vars", WRAM0
currFrame:: DS 1
playerX:: DS 1
playerY:: DS 1
playerIO:: DS 1

playerJumpTimer:: DS 1
playerGrounded:: DS 1
playerJumping:: DS 1
playerVelocityY:: DS 1

SECTION "frames", ROMX[$5D00]
frames:
    DB $00, $00, $00, $00, $00, $00, $00, $00, $01, $01, $01, $01, $01, $01, $01, $01, $02, $02, $02, $02, $02, $02, $02, $02, $01, $01, $01, $01, $01, $01, $01, $01
